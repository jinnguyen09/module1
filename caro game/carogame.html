<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ ch∆°i c·ªù ca-ro</title>
    <link rel="stylesheet" type="text/css" href="home.css">
    <link rel="stylesheet" type="text/css" href="carogame.css">
</head>
<style>
    .button {
        padding: 0;
        cursor: pointer;
        position: absolute;
        top: 10px;
        right: 10px;
        margin: 10px;
        font-size: 100px;
        max-width: 100%;
        height: auto;
    }
    body {
        width: 100%;
        overflow-x: hidden; /* NgƒÉn tr√†n ngang */
    }
</style>

<body>
    <div id="container">
        <div style="margin-top: 150px;">
            <div style="margin-bottom: 10px;">
                <select id="sizeGameBoard">
                    <option value="10">10 x 10</option>
                    <option value="15">15 x 15</option>
                    <option value="20">20 x 20</option>
                </select>
                <button onclick="start()">Ch∆°i</button>
                
            </div>
            
            <div id="gameBoard-wrapper">
                <table id="gameBoard"></table>
            </div>
            <h1 style="color: palevioletred; background-color: black; display: block; text-align: center;">By Nguyen Dinh Thiep</h1> <br> 
            <div id="winResult">K·∫øt qu·∫£
                <hr style="color: red;">
                <div id="result"></div>
            </div>
        </div>
        <div class="button" style="display: block;">
            <div onclick="handleBack()" id="back" title="Quay l·∫°i trang ch·ªß" style="display: inline-block;">‚Ü©Ô∏è</div>
            <div id="playPauseMusic" onclick="switchMusic()" style="display: inline-block;">üîä</div>
            <audio id="myMusic" src="music.mp3" muted autoplay></audio>
        </div>
    </div>
    
    <script>
        let onMusic = false;
        const audio = document.getElementById("myMusic")
        audio.volume = 0.5;
        let music = document.getElementById("playPauseMusic");
        function switchMusic() {
            onMusic = !onMusic;
            if (onMusic) {
                audio.play();
                music.innerText = `üîä`
            } else {
                audio.pause();
                music.innerText = `üîá`
            }
        }

        window.addEventListener("load", () => {
            onMusic = true;
            const audio = document.getElementById("myMusic");
            audio.muted = false; // B·ªè mute sau khi audio b·∫Øt ƒë·∫ßu ph√°t
        });
        
        function handleBack() {
            const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^/]*$/, "");
            window.location.href = `${baseUrl}/index.html`;
        }

        let gameMode = "";

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('type') === 'withPlayer') {
            gameMode = "player";
        } else {
            gameMode = "computer";
        }

        let round = 1;

        function Cell(x, y) {
            this.x = x;
            this.y = y;
            this.value = null;
            this.getHtml = function () {
                return `<td id="cell-${x}-${y}" onclick="tick(${x},${y})"></td>`;
            };
        }

        function GameBoard(size) {
            this.size = size;
            this.turn = "X";
            this.cells = [];
            this.isOver = false;
            this.lastMoves = new Set(); // Gi·ªõi h·∫°n v√πng t√¨m ki·∫øm

            this.draw = function () {
                let gameBoard = "";
                for (let i = 0; i < this.size; i++) {
                    let row = [];
                    this.cells.push(row);
                    gameBoard += "<tr>";
                    for (let j = 0; j < this.size; j++) {
                        let cell = new Cell(i, j);
                        row.push(cell);
                        gameBoard += cell.getHtml();
                    }
                    gameBoard += "</tr>";
                }
                document.getElementById('gameBoard').innerHTML = gameBoard;
            };

            this.markGameBoard = function (x, y) {
                if (this.isOver) return;
                let cell = this.cells[x][y];
                let element = document.getElementById(`cell-${x}-${y}`);
                if (!cell.value) {
                    cell.value = element.innerHTML = this.turn;
                    this.isOver = this.checkWin(x, y, this.turn);
                    this.turn = this.turn === "X" ? "O" : "X";
                    element.style.cursor = "not-allowed";
                    this.lastMoves.add([x, y]); // Th√™m √¥ v·ª´a ƒë√°nh v√†o v√πng t√¨m ki·∫øm

                    if (gameMode === "computer" && this.turn === "O" && !this.isOver) {
                        setTimeout(() => this.computerMove(), 500);
                    }
                }
            };

            this.computerMove = function () {
                let ai = new GomokuAI(this); // this tham chi·∫øu ƒë·∫øn instance c·ªßa l·ªõp GameBoard
                let bestMove = ai.findBestMove();
                if (bestMove) this.markGameBoard(bestMove.x, bestMove.y);
            };

            const highlightWinningCells = (winningCells) => {
                for (let [row, col] of winningCells) {
                    document.getElementById(`cell-${row}-${col}`).classList.add("winning-cell");
                }
            };

            this.checkWin = function (x, y, player) {
                const directions = [
                    [0, 1], // H∆∞·ªõng Ngang
                    [1, 0], // H∆∞·ªõng D·ªçc
                    [1, 1], // H∆∞·ªõng Ch√©o ch√≠nh
                    [1, -1] // H∆∞·ªõng Ch√©o ph·ª•
                ];

                for (let [dx, dy] of directions) {
                    let winningCells = [[x, y]];
                    let count = 1;
                    for (let step = 1; step < 5; step++) {
                        let nx = x + step * dx;
                        let ny = y + step * dy;
                        if (
                            nx >= 0 && nx < this.size &&
                            ny >= 0 && ny < this.size &&
                            this.cells[nx][ny].value === player
                        ) {
                            winningCells.push([nx, ny]);
                            count++;
                        } else {
                            break;
                        }
                    }

                    for (let step = 1; step < 5; step++) {
                        let nx = x - step * dx;
                        let ny = y - step * dy;
                        if (
                            nx >= 0 && nx < this.size &&
                            ny >= 0 && ny < this.size &&
                            this.cells[nx][ny].value === player
                        ) {
                            count++;
                            winningCells.push([nx, ny]);
                        } else {
                            break;
                        }
                    }

                    if (count >= 5) {
                        highlightWinningCells(winningCells);
                        document.getElementById("result").innerHTML += `${round}. ${player} th·∫Øng<br>`;
                        round++;
                        return true;
                    }
                }
                return false;
            };
        }

        function GomokuAI(gameBoard) {
            this.board = gameBoard;
            this.EMPTY = null;

            this.findBestMove = function (depth = 3) {
                let bestValue = -Infinity;
                let bestMove = null;

                const possibleMoves = this.getDynamicMoves(); // Gi·ªõi h·∫°n t√¨m ki·∫øm
                for (let move of possibleMoves) {
                    const [x, y] = move;
                    this.board.cells[x][y].value = "O";
                    let moveValue = this.minimax(depth - 1, -Infinity, Infinity, false);
                    this.board.cells[x][y].value = this.EMPTY;

                    if (moveValue > bestValue) {
                        bestValue = moveValue;
                        bestMove = { x, y };
                    }
                }
                return bestMove;
            };

            this.getDynamicMoves = function () {
                const range = 1; // Gi·ªõi h·∫°n v√πng xung quanh √¥ ƒë√£ ƒë√°nh
                const moves = new Set();

                this.board.lastMoves.forEach((move) => {
                    const [x, y] = move;
                    for (let dx = -range; dx <= range; dx++) {
                        for (let dy = -range; dy <= range; dy++) {
                            let nx = x + dx;
                            let ny = y + dy;
                            if (
                                nx >= 0 && nx < this.board.size &&
                                ny >= 0 && ny < this.board.size &&
                                this.board.cells[nx][ny].value === this.EMPTY
                            ) {
                                moves.add(`${nx}-${ny}`); // Th√™m chu·ªói ƒë·ªÉ nh·∫≠n di·ªán set
                            }
                        }
                    }
                });

                return Array.from(moves).map(coord => coord.split('-').map(Number)); // Chuy·ªÉn chu·ªói v·ªÅ m·∫£ng [x, y]
            };


            this.minimax = function (depth, alpha, beta, isMaximizing) {
                if (depth === 0) {
                    return this.evaluateBoard();
                }

                const possibleMoves = this.getDynamicMoves(); // Ch·ªâ duy·ªát trong v√πng t√¨m ki·∫øm

                if (isMaximizing) {
                    let maxEval = -Infinity;
                    for (let move of possibleMoves) {
                        const [x, y] = move;
                        this.board.cells[x][y].value = "O";
                        let eval = this.minimax(depth - 1, alpha, beta, false);
                        this.board.cells[x][y].value = this.EMPTY;
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break;
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (let move of possibleMoves) {
                        const [x, y] = move;
                        this.board.cells[x][y].value = "X";
                        let eval = this.minimax(depth - 1, alpha, beta, true);
                        this.board.cells[x][y].value = this.EMPTY;
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            };

            this.evaluateBoard = function () {
                let score = 0;

                const evaluateLine = (line) => {
                    let countO = 0;
                    let countX = 0;
                    const attackWeight = 100; // Tr·ªçng s·ªë t·∫•n c√¥ng
                    const defenseWeight = 100; // Tr·ªçng s·ªë ph√≤ng th·ªß
                    for (let cell of line) {
                        if (cell === "O") countO++;
                        else if (cell === "X") countX++;
                    }

                    if (countO > 0 && countX === 0) {
                        score += attackWeight * Math.pow(10, countO);
                    } else if (countX > 0 && countO === 0) {
                        score -= defenseWeight * Math.pow(10, countX);
                    }
                };

                const getLine = (x, y, dx, dy) => {
                    let line = [];
                    for (let i = 0; i <= 4; i++) {
                        let nx = x + i * dx;
                        let ny = y + i * dy;
                        if (nx >= 0 && nx < this.board.size && ny >= 0 && ny < this.board.size) {
                            line.push(this.board.cells[nx][ny].value);
                        } else break;
                    }
                    return line;
                };

                const evaluateDynamicLines = () => {
                   const directions = [
                        [0, 1],  // Horizontal
                        [1, 0],  // Vertical
                        [1, 1],  // Diagonal down-right
                        [1, -1], // Diagonal up-right
                    ];

                    this.board.lastMoves.forEach(([x, y]) => { // L·∫∑p qua c√°c n∆∞·ªõc ƒëi g·∫ßn nh·∫•t 
                        directions.forEach(([dx, dy]) => { // Duy·ªát qua c√°c h∆∞·ªõng t·ª´ n∆∞·ªõc ƒëi hi·ªán t·∫°i (ki·ªÉm tra 4 h∆∞·ªõng)
                            for (let i = -4; i <= 0; i++) { // Duy·ªát ki·ªÉm tra tr∆∞·ªõc n∆∞·ªõc v·ª´a ƒë√°nh c√≥ v∆∞·ª£t kh·ªèi khu v·ª±c ch∆°i
                                const startX = x + i * dx;
                                const startY = y + i * dy;
                                if (
                                    startX >= 0 && startX < this.board.size &&
                                    startY >= 0 && startY < this.board.size
                                ) evaluateLine(getLine(startX, startY, dx, dy));
                            }
                        });
                    });
                };
                evaluateDynamicLines();
                return score;
            };
        }

        let gameBoard;
        function start() {
            let size = document.getElementById("sizeGameBoard").value;
            gameBoard = new GameBoard(size);
            gameBoard.draw();
        }

        function tick(x, y) {
            gameBoard.markGameBoard(x, y);
        }

        start();
        // switchMusic()
    </script>

</body>
</html>